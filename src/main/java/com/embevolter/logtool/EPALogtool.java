package com.embevolter.logtool;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.logging.Logger;

import com.embevolter.logtool.model.Datetime;
import com.embevolter.logtool.model.LogLine;
import com.embevolter.logtool.model.ServerRequest;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;

/**
* The EPALogtool class implements file processing operations for 
* a logfile generated by EPA's WWW server in 1995.
* A JSON file can be generated from the input.
*
* @author  Bogdan Mircea
* @version 1.0
* @since   2020-07-20 
*/

class EPALogtool implements LogtoolInterface<LogLine> {
   
    static final Logger logger = Logger.getLogger(EPALogtool.class.getName());
    
    private String inputFileName;
    private File inputFile;
    private File outputFile;
    private FileInputStream fileInputStream;

    private ObjectMapper mapper;
    private ObjectWriter writer;
    
    public EPALogtool(String inputFileName) {
        this.inputFileName = inputFileName;
    }

    public String getOutputFileName(String inputFileName) {
        return inputFileName.replace("txt", "json");
    }

    private void initReader() {
        try {
            if (inputFile == null) 
                inputFile = new File(inputFileName);
            
            if (fileInputStream == null) 
                fileInputStream = new FileInputStream(inputFile);

        } catch (NullPointerException e) {
            logger.warning("You have not provided an input file!");
        } catch (FileNotFoundException e) {
            logger.warning(String.format("The resource from %s cannot be read!", inputFileName));
        }
    }

    public Scanner initFileScanner() throws IllegalArgumentException {
        initReader();

        return new Scanner(fileInputStream, "ASCII");
    }

    private void initWriter() throws Exception {
        if (outputFile == null) 
            outputFile = new File(getOutputFileName(inputFileName));

        if (mapper == null) 
            mapper = new ObjectMapper();
        
        if (writer == null) 
            writer = mapper.writer(new DefaultPrettyPrinter());
    }

    private void closeReader() {
        try {
            fileInputStream.close();
        } catch (IOException e) {
            logger.warning("Error when closing writer.");
        }
    }
    
    /**
     * Read every log entries and process it
     * 
     */
        //
    //
    @Override
    public List<LogLine> readProcessor() {
        //init captured logLines 
        List<LogLine> logLinesToWrite = new ArrayList<LogLine>();

        try (Scanner sc = initFileScanner() ) {
            while (sc.hasNextLine()) {
                String line = sc.nextLine();

                line = Utils.removeASCIIControlCharactersFromString(line);

                LogLine l = this.readLine(line);
                logLinesToWrite.add(l);
            }

            // note that Scanner suppresses exceptions
            if (sc.ioException() != null) {
                throw sc.ioException();
            }
        } catch (final IOException e) {
            e.printStackTrace();
        } finally {
            this.closeReader();
        }
        return logLinesToWrite;
    }

    public LogLine readLine(String lineText) {
        if (lineText == null) return null;

        try {
            String[] lineTokens = lineText.split(" ");
            int lineTokensLength = lineTokens.length;

            //the array is split to capture each resource fromo the current line in the log
            //resource: host
            String host = lineTokens[0];

            //resource: datetime {dd,hh,mm,ss}
            Datetime datetime = readDatetimeChunk(lineTokens[1]);

            //because length is variable for serverRequest resources, a dynamic array is captured
            String[] serverRequestTokens = Utils.getArraySubset(lineTokens, 2, lineTokensLength - 2);
                                
            //resource: serverRequest [requestMethod, urlPath, protocol/protocolVersion] is parsed
            ServerRequest serverRequest = readServerRequestChunk(serverRequestTokens);
            
            //resource: responseCode
            String responseCode = lineTokens[lineTokensLength-2];

            //resource: documentSize
            String documentSize = lineTokens[lineTokensLength-1];

            return new LogLine(host, datetime, serverRequest, responseCode, documentSize);
        } catch (Exception e) {
            logger.warning("Error while reading line in file: " + inputFileName);
            return null;
        }
    } 

    private Datetime readDatetimeChunk(String datetimeSequence) {
        //"Datetime" sequence is stripped of leading and trailing brackets
        //and split into its discrete elements
        String dateTimeElements[] = datetimeSequence
            .substring(1, datetimeSequence.length()-1)
            .split(":");

        int[] intDatetimeElements = Utils.parseToIntArray(dateTimeElements);
        
        return new Datetime(intDatetimeElements[0], intDatetimeElements[1], intDatetimeElements[2], intDatetimeElements[3]);
    }

    //TODO: workTODO
    private ServerRequest readServerRequestChunk(String[] serverRequestSequence) {
        
        int serverRequestSequenceLength = serverRequestSequence.length;

        //remove first character of the sequence (a double quotation mark)
        String httpRequestMethod = serverRequestSequence[0].substring(1);

        //TODO:comment

        String urlSequence = 
            Utils.getArraySubsetToString(serverRequestSequence, 1, serverRequestSequenceLength - 1);

        //TODO:TEST for existence 
        String protocolSequence = (serverRequestSequenceLength >= 2) 
            ? serverRequestSequence[serverRequestSequenceLength-1] : null;


        int protocolSequenceSeparatorIndex = (protocolSequence != null) 
            ? protocolSequence.indexOf("/") : 0;

        String protocol = (protocolSequence != null) 
            ? protocolSequence.substring(0, protocolSequenceSeparatorIndex) : "";
            
        String protocolVersion = (protocolSequence != null) 
            ? protocolSequence.substring(
                protocolSequenceSeparatorIndex+1, protocolSequence.length()-1) : "";

        return new ServerRequest(httpRequestMethod, urlSequence, protocol, protocolVersion);
    }

        //the EPALogtool implementation is used to write a list of objects into a JSON file
        @Override
        public void writeProcessor(List<LogLine> logLines) {
            try {
                initWriter();
    
                writer.writeValue(outputFile, logLines);
            } catch (Exception ex) {
                //TODO: make it more specific
                logger.warning("Error during writing to the JSON file");
            } 
        }
}